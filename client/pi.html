<!DOCTYPE html>
<!--
Note: this is a single large HTML file to sidestep CORS issues.
Script is heavily based on three.js examples: https://threejs.org/examples/
-->
<html lang="en">
<head>
    <title>gedankenpolizei</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        /* Styling taken from Three.js examples */
        :root {
            color-scheme: light dark;
            --background-color: #fff;
            --secondary-background-color: #f7f7f7;
            --color-blue: #049EF4;
            --text-color: #444;
            --secondary-text-color: #9e9e9e;
            --font-size: 16px;
            --line-height: 26px;
            --border-style: 2px solid #E8E8E8;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --background-color: #222;
                --secondary-background-color: #2e2e2e;
                --text-color: #bbb;
                --secondary-text-color: #666;
                --border-style: 2px solid #444;
            }
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000; /* Ensure this is black; otherwise lens distortion reveals a grey band (the default body background-color I guess) */
        }

        canvas {
            display: block;
        }

        #infoBox {
            position: absolute;
            bottom: 10px;
            right: 10px;
            padding: 10px;
            font-family: 'Roboto Mono', monospace;
            font-size: calc(var(--font-size) - 2px);
            color: var(--text-color);
            border-radius: 5px;
            border: var(--border-style);
            background-color: rgba(0, 0, 0, 0.5);
        }

        #infoBox p {
            margin-top: 0.3em;
            margin-bottom: 0.3em;
        }

        #infoBox .centered {
            text-align: center; /* Center the first paragraph */
        }

        #infoBox .aligned {
            display: flex;
            justify-content: space-between;
            white-space: pre; /* Preserve spaces */
        }
    </style>
</head>
<body>
    <div id="infoBox">
        <p class="centered"><strong>gedankenpolizei</strong></p>
        <p class="aligned">[SPACE] (un)lock camera</p>
        <p class="aligned">    [C] toggle controls</p>
        <p class="aligned">    [M] (un)mute</p>
        <p class="aligned">    [L] log parameters</p>
        <p class="aligned">    [I] toggle invert colors</p>
        <p class="aligned">    [H] toggle info box</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/",
                "three-lens-distortion": "https://cdn.jsdelivr.net/gh/ycw/three-lens-distortion@1.0.0/src/index.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { Pass, FullScreenQuad } from "three/addons/postprocessing/Pass";
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { LuminosityShader } from 'three/addons/shaders/LuminosityShader.js';
        import { LensDistortionPassGen } from 'three-lens-distortion';

        // ---------------------------------------------------------------------------
        // Color Dipole Shader
        const ColorDipoleShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "color1": { value: new THREE.Color(0x000000) },
                "color2": { value: new THREE.Color(0xffffff) },
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec3 color1;
                uniform vec3 color2;
                varying vec2 vUv;

                void main() {
                    vec4 color = texture2D( tDiffuse, vUv );
                    float luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                    gl_FragColor = vec4( mix(color2, color1, luminance), color.a );
                }
            `
        };

        // ---------------------------------------------------------------------------
        // Invert Color Shader
        const InvertColorShader = {
            uniforms: {
                "tDiffuse": { value: null }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                varying vec2 vUv;

                void main() {
                    vec4 color = texture2D( tDiffuse, vUv );
                    gl_FragColor = vec4( vec3( 1.0 - color.rgb ), color.a );
                }
            `
        };

        // ---------------------------------------------------------------------------
        // Settings
        // ---------------------------------------------------------------------------

        // Controls GUI
        let gui; // Declare gui globally
        let controlsVisible = false; // Track the visibility of controls
        const cameraSpeed = 10; // Speed of camera nudge

        // Text display parameters
        const textDisplayParams = {
            TEXT_CANVAS_WIDTH: 300,
            TEXT_CANVAS_HEIGHT: 120,
            FONT_SIZE: 20,
            FONT_FAMILY: 'Arial Unicode MS, Arial, sans-serif',
            TEXT_STYLE: 'rgba(255, 255, 255, 1.0)',
            LINE_HEIGHT: 19,
            TEXT_X_OFFSET: 20,
            TEXT_Y_OFFSET: 50,
            PROB_ELVISH: 0.02,
            BORDER_WIDTH: 2,
            BORDER_DASHED: false,
            BORDER_DASH_SIZE: 10,
            BORDER_GAP_SIZE: 5,
            BORDER_COUNT: 1,
            BORDER_SPACING: 5,
            BORDER_RADIUS: 0,
        };

        // Color Dipole parameters
        const colorDipoleParams = {
            color1: '#000000', // Dark color
            color2: '#ffffff', // Light color
            enabled: true,
        };

        // Audio
        const AUDIO_GAIN = 5.0;
        const CLICK_SOUND_DURATION = 80; // msec

        // Websocket
        const WS_TEXT_URL = 'ws://localhost:8766';
        const WS_TEXT_RETRY = 500; // msec

        // Scene
        let scene, camera, renderer, composer, bloomPass, lensDistortionPass, colorDipolePass, invertColorPass;
        let mouse, center;
        const initialCameraPosition = new THREE.Vector3(-63.984445903689256, 64.01760287088358, 686.1194448349208);
        let targetCameraPosition = initialCameraPosition.clone();
        let textMesh;
        let textBuffer = ""; // Buffer for incoming text
        let cameraLocked = true; // Flag to lock the camera

        // Variables for PositionalAudio
        let listener, pinkNoise, gainNode, currentGain = AUDIO_GAIN;
        let isMuted = false; // Flag to mute the sound

        window.onload = init;

        // ---------------------------------------------------------------------------
        // Setup scene and websockets
        // ---------------------------------------------------------------------------
        function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            // Setup camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.copy(initialCameraPosition);

            // Initialize cameraParams
            const cameraParams = {
                positionX: camera.position.x,
                positionY: camera.position.y,
                positionZ: camera.position.z,
            };

            // Setup scene and renderer
            scene = new THREE.Scene();
            center = new THREE.Vector3();
            center.z = -1000;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setAnimationLoop(animate);
            container.appendChild(renderer.domElement);

            // Setup postprocessing
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));

            // Bloom pass
            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, // Strength
                0.4, // Radius
                0.85 // Threshold
            );
            composer.addPass(bloomPass);

            // Color to grayscale conversion
            const effectGrayScale = new ShaderPass(LuminosityShader);
            composer.addPass(effectGrayScale);

            // Lens distortion
            const LensDistortionPass = LensDistortionPassGen({ THREE, Pass, FullScreenQuad });
            lensDistortionPass = new LensDistortionPass({
                distortion: new THREE.Vector2(0.1, 0.1),
                principalPoint: new THREE.Vector2(0.0, 0.0),
                focalLength: new THREE.Vector2(1.0, 1.0),
                skew: 0.0
            });
            composer.addPass(lensDistortionPass);

            // Color Dipole pass
            colorDipolePass = new ShaderPass(ColorDipoleShader);
            colorDipolePass.uniforms['color1'].value = new THREE.Color(colorDipoleParams.color1);
            colorDipolePass.uniforms['color2'].value = new THREE.Color(colorDipoleParams.color2);
            colorDipolePass.enabled = colorDipoleParams.enabled;
            composer.addPass(colorDipolePass);

            // Invert Color pass
            invertColorPass = new ShaderPass(InvertColorShader);
            invertColorPass.enabled = false; // Start with it disabled
            composer.addPass(invertColorPass);

            // Handle user input
            mouse = new THREE.Vector3(0, 0, 1);
            document.addEventListener('mousemove', onDocumentMouseMove);
            document.addEventListener('mouseleave', onDocumentMouseLeave);
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('wheel', onDocumentMouseWheel);

            document.addEventListener('touchstart', onDocumentTouchStart, false);
            document.addEventListener('touchmove', onDocumentTouchMove, false);

            document.addEventListener('keydown', onDocumentKeyDown);

            // Hide the GUI by default
            gui = new GUI();
            gui.hide();

            // Add bloom controls to GUI
            const bloomFolder = gui.addFolder('Bloom');
            bloomFolder.add(bloomPass, 'strength', 0, 3, 0.01).name('Strength');
            bloomFolder.add(bloomPass, 'radius', 0, 1, 0.01).name('Radius');
            bloomFolder.add(bloomPass, 'threshold', 0, 1, 0.01).name('Threshold');
            bloomFolder.close();

            // Add lens distortion controls to GUI
            const lensDistortionFolder = gui.addFolder('Lens Distortion');
            lensDistortionFolder.add(lensDistortionPass.distortion, 'x', -1, 1, 0.01).name('Distortion X');
            lensDistortionFolder.add(lensDistortionPass.distortion, 'y', -1, 1, 0.01).name('Distortion Y');
            lensDistortionFolder.add(lensDistortionPass.principalPoint, 'x', -0.5, 0.5, 0.01).name('Principal Point X');
            lensDistortionFolder.add(lensDistortionPass.principalPoint, 'y', -0.5, 0.5, 0.01).name('Principal Point Y');
            lensDistortionFolder.add(lensDistortionPass.focalLength, 'x', 0, 2, 0.01).name('Focal Length X');
            lensDistortionFolder.add(lensDistortionPass.focalLength, 'y', 0, 2, 0.01).name('Focal Length Y');
            lensDistortionFolder.add(lensDistortionPass, 'skew', -Math.PI / 2, Math.PI / 2, 0.01).name('Skew');
            lensDistortionFolder.close();

            // Add Text Display controls to GUI
            const textDisplayFolder = gui.addFolder('Text Display');
            textDisplayFolder.add(textDisplayParams, 'TEXT_CANVAS_WIDTH', 100, 2000, 1).name('Canvas Width').onChange(updateTextCanvasDimensions);
            textDisplayFolder.add(textDisplayParams, 'TEXT_CANVAS_HEIGHT', 100, 2000, 1).name('Canvas Height').onChange(updateTextCanvasDimensions);
            textDisplayFolder.add(textDisplayParams, 'FONT_SIZE', 1, 100, 1).name('Font Size').onChange(updateTextCanvas);
            textDisplayFolder.add(textDisplayParams, 'FONT_FAMILY').name('Font Family').onChange(updateTextCanvas);
            textDisplayFolder.addColor(textDisplayParams, 'TEXT_STYLE').name('Text Style').onChange(updateTextCanvas);
            textDisplayFolder.add(textDisplayParams, 'LINE_HEIGHT', 1, 200, 1).name('Line Height').onChange(updateTextCanvas);
            textDisplayFolder.add(textDisplayParams, 'TEXT_X_OFFSET', 0, 500, 1).name('Text X Offset').onChange(updateTextCanvas);
            textDisplayFolder.add(textDisplayParams, 'TEXT_Y_OFFSET', 0, 500, 1).name('Text Y Offset').onChange(updateTextCanvas);
            textDisplayFolder.add(textDisplayParams, 'PROB_ELVISH', 0, 1, 0.01).name('p(Elvish)').onChange(updateTextCanvas);
            textDisplayFolder.close();

            // Add Border Settings to GUI
            const borderFolder = gui.addFolder('Border Settings');
            borderFolder.add(textDisplayParams, 'BORDER_COUNT', 0, 10, 1).name('Border Count').onChange(updateTextCanvas);
            borderFolder.add(textDisplayParams, 'BORDER_SPACING', 0, 50, 1).name('Border Spacing').onChange(updateTextCanvas);
            borderFolder.add(textDisplayParams, 'BORDER_WIDTH', 1, 20, 1).name('Border Width').onChange(updateTextCanvas);
            borderFolder.add(textDisplayParams, 'BORDER_RADIUS', 0, 50, 1).name('Border Radius').onChange(updateTextCanvas);
            borderFolder.add(textDisplayParams, 'BORDER_DASHED').name('Dashed').onChange(updateTextCanvas);
            borderFolder.add(textDisplayParams, 'BORDER_DASH_SIZE', 1, 50, 1).name('Dash Size').onChange(updateTextCanvas);
            borderFolder.add(textDisplayParams, 'BORDER_GAP_SIZE', 0, 50, 1).name('Gap Size').onChange(updateTextCanvas);
            borderFolder.close();

            // Add Color Dipole controls to GUI
            const colorDipoleFolder = gui.addFolder('Color Dipole');
            colorDipoleFolder.addColor(colorDipoleParams, 'color1').name('Color 1').onChange(() => {
                colorDipolePass.uniforms['color1'].value.set(colorDipoleParams.color1);
            });
            colorDipoleFolder.addColor(colorDipoleParams, 'color2').name('Color 2').onChange(() => {
                colorDipolePass.uniforms['color2'].value.set(colorDipoleParams.color2);
            });
            colorDipoleFolder.add(colorDipoleParams, 'enabled').name('Enable').onChange(() => {
                colorDipolePass.enabled = colorDipoleParams.enabled;
            });
            colorDipoleFolder.close();

            // Add Camera controls to GUI
            const cameraFolder = gui.addFolder('Camera');
            cameraFolder.add(cameraParams, 'positionX').name('Position X').onChange(updateCameraPosition);
            cameraFolder.add(cameraParams, 'positionY').name('Position Y').onChange(updateCameraPosition);
            cameraFolder.add(cameraParams, 'positionZ').name('Position Z').onChange(updateCameraPosition);
            cameraFolder.close();

            setupTextCanvas();
            connectWebSocketText();
            setupAudio();

            function updateCameraPosition() {
                camera.position.set(cameraParams.positionX, cameraParams.positionY, cameraParams.positionZ);
                camera.lookAt(center);
            }
        }

        function animate() {
            if (!cameraLocked) {
                camera.position.lerp(targetCameraPosition, 0.05);
                camera.lookAt(center);
            }
            composer.render(); // Use composer instead of renderer
        }

        // ---------------------------------------------------------------------------
        // Audio
        // ---------------------------------------------------------------------------
        function setupAudio() {
            listener = new THREE.AudioListener();
            camera.add(listener);
            pinkNoise = createPinkNoise(listener.context);

            // Create GainNode to control pinkNoise volume
            gainNode = listener.context.createGain();
            gainNode.gain.value = currentGain;

            // Add gain control to Controls GUI
            const audioFolder = gui.addFolder('Audio');
            const gainControl = audioFolder.add(gainNode.gain, 'value', 0.0, AUDIO_GAIN * 2, 1).name('Volume').listen();
            gainControl.onChange((value) => {
                if (!isMuted) {
                    currentGain = gainNode.gain.value; // Update current gain value when not muted
                }
            });
            audioFolder.close();
        }

        function normalRandom() {
            let u = 0, v = 0;
            while (u === 0) u = Math.random(); // Converting [0,1) to (0,1)
            while (v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }

        function createPinkNoise(audioContext) {
            const bufferSize = 4096;
            const node = audioContext.createScriptProcessor(bufferSize, 1, 1);
            let b0, b1, b2, b3, b4, b5, b6;
            b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;

            node.onaudioprocess = function (e) {
                const output = e.outputBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    const white = normalRandom();
                    b0 = 0.99886 * b0 + white * 0.0555179;
                    b1 = 0.99332 * b1 + white * 0.0750759;
                    b2 = 0.96900 * b2 + white * 0.1538520;
                    b3 = 0.86650 * b3 + white * 0.3104856;
                    b4 = 0.55000 * b4 + white * 0.5329522;
                    b5 = -0.7616 * b5 - white * 0.0168980;
                    output[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                    output[i] *= 0.11; // (roughly) compensate for gain
                    b6 = white * 0.115926;

                    output[i] /= 400; // Normalize the pink noise
                    output[i] /= Math.sqrt(1 - i / bufferSize); // Fade out the pink noise
                }
            };

            return node;
        }

        function playClickSound() {
            // Start and stop the pink noise after a short duration
            pinkNoise.connect(gainNode).connect(listener.context.destination);
            setTimeout(() => {
                pinkNoise.disconnect();
            }, CLICK_SOUND_DURATION);
        }

        function toggleMute(mute) {
            if (mute) {
                currentGain = gainNode.gain.value; // Remember the current gain
                gainNode.gain.value = 0;
            } else {
                gainNode.gain.value = currentGain; // Restore the remembered gain
            }
            isMuted = mute;
        }

        // ---------------------------------------------------------------------------
        // Setup text canvas to display incoming text with Elvish effect
        // ---------------------------------------------------------------------------
        function setupTextCanvas() {
            const canvas = document.createElement('canvas');
            canvas.width = textDisplayParams.TEXT_CANVAS_WIDTH;
            canvas.height = textDisplayParams.TEXT_CANVAS_HEIGHT;
            const context = canvas.getContext('2d');

            const textTexture = new THREE.CanvasTexture(canvas);
            textTexture.needsUpdate = true;

            const textMaterial = new THREE.MeshBasicMaterial({
                map: textTexture,
                transparent: true,
            });
            const textGeometry = new THREE.PlaneGeometry(textDisplayParams.TEXT_CANVAS_WIDTH, textDisplayParams.TEXT_CANVAS_HEIGHT);
            textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.set(0, 0, 100);
            scene.add(textMesh);

            updateTextCanvas(); // Initial rendering
        }

        function updateTextCanvasDimensions() {
            // Update canvas dimensions and mesh geometry
            const canvas = textMesh.material.map.image;
            canvas.width = textDisplayParams.TEXT_CANVAS_WIDTH;
            canvas.height = textDisplayParams.TEXT_CANVAS_HEIGHT;
            textMesh.geometry = new THREE.PlaneGeometry(textDisplayParams.TEXT_CANVAS_WIDTH, textDisplayParams.TEXT_CANVAS_HEIGHT);
            textMesh.material.map.needsUpdate = true;

            updateTextCanvas();
        }

        // Helper function to draw rounded rectangles
        function drawRoundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        // Helper function to randomly add combining characters and embellish spaces
        function addElvishEffect(text) {
            const combiningMarks = [
                '\u0300', // Grave accent
                '\u0301', // Acute accent
                '\u0302', // Circumflex
                '\u0303', // Tilde
                '\u0304', // Macron
                '\u0305', // Overline
                '\u0306', // Breve
                '\u0307', // Dot above
                '\u0308', // Diaeresis
                '\u030A', // Ring above
                '\u030B', // Double acute accent
                '\u030C', // Caron
                '\u0323', // Dot below
                '\u0324', // Diaeresis below
                '\u0325', // Ring below
                '\u0326', // Comma below
                '\u0327', // Cedilla
                '\u0328', // Ogonek
                '\u0331', // Macron below
                '\u0332', // Low line (underline)
                '\u0338', // Long slash overlay
                '\u0361'  // Double inverted breve
            ];

            const spaceVariants = [
                '\u0020', // Space
                '\u00A0', // Non-breaking space
                '\u2000', // En quad
                '\u2001', // Em quad
                '\u2002', // En space
                '\u2003', // Em space
                '\u2004', // Three-per-em space
                '\u2005', // Four-per-em space
                '\u2006', // Six-per-em space
                '\u2007', // Figure space
                '\u2008', // Punctuation space
                '\u2009', // Thin space
                '\u200A', // Hair space
                '\u202F', // Narrow no-break space
                '\u205F', // Medium mathematical space
                '\u3000'  // Ideographic space
            ];

            let result = '';
            for (let char of text) {
                if (char === ' ') {
                    // Randomly decide whether to replace the space
                    if (Math.random() < textDisplayParams.PROB_ELVISH) {
                        const spaceChar = spaceVariants[Math.floor(Math.random() * spaceVariants.length)];
                        result += spaceChar;
                    } else {
                        result += char;
                    }
                } else {
                    // TODO: I disabled this for now... fix later
                    result += char;
                }
            }
            return result;
        }

        // Update the text canvas with new messages
        function updateTextCanvas() {
            const canvas = textMesh.material.map.image;
            const context = canvas.getContext('2d');
            context.clearRect(0, 0, canvas.width, canvas.height);

            // Draw borders
            if (textDisplayParams.BORDER_COUNT > 0) {
                for (let i = 0; i < textDisplayParams.BORDER_COUNT; i++) {
                    let offset = i * (textDisplayParams.BORDER_SPACING + textDisplayParams.BORDER_WIDTH);
                    context.lineWidth = textDisplayParams.BORDER_WIDTH;
                    context.strokeStyle = textDisplayParams.TEXT_STYLE; // Use text color for border
                    if (textDisplayParams.BORDER_DASHED) {
                        context.setLineDash([textDisplayParams.BORDER_DASH_SIZE, textDisplayParams.BORDER_GAP_SIZE]);
                    } else {
                        context.setLineDash([]);
                    }
                    drawRoundedRect(
                        context,
                        offset + textDisplayParams.BORDER_WIDTH / 2,
                        offset + textDisplayParams.BORDER_WIDTH / 2,
                        canvas.width - 2 * offset - textDisplayParams.BORDER_WIDTH,
                        canvas.height - 2 * offset - textDisplayParams.BORDER_WIDTH,
                        textDisplayParams.BORDER_RADIUS
                    );
                    context.stroke();
                }
            }

            // Draw text
            context.font = `bold ${textDisplayParams.FONT_SIZE}px ${textDisplayParams.FONT_FAMILY}`;
            context.fillStyle = textDisplayParams.TEXT_STYLE;
            context.textAlign = 'left';

            const MAX_TEXT_WIDTH = textDisplayParams.TEXT_CANVAS_WIDTH - textDisplayParams.TEXT_X_OFFSET * 2;
            const maxLines = Math.floor((canvas.height - textDisplayParams.TEXT_Y_OFFSET) / textDisplayParams.LINE_HEIGHT);
            let currentY = textDisplayParams.TEXT_Y_OFFSET;

            let wrappedText = '';
            let lastWhitespaceIndex = -1;
            let lineStartIndex = 0;

            // Apply Elvish effect to the textBuffer
            textBuffer = addElvishEffect(textBuffer);

            for (let i = 0; i < textBuffer.length; i++) {
                let char = textBuffer[i];
                wrappedText += char;

                // Handle newlines as hard wraps
                if (char === '\n') {
                    lineStartIndex = wrappedText.length;
                    lastWhitespaceIndex = -1;
                    continue;
                }

                if (/\s/.test(char)) {
                    lastWhitespaceIndex = wrappedText.length - 1;
                }

                let currentLine = wrappedText.substring(lineStartIndex);
                let lineWidth = context.measureText(currentLine).width;

                if (lineWidth > MAX_TEXT_WIDTH) {
                    if (lastWhitespaceIndex >= lineStartIndex) {
                        // Insert a newline *at* the last whitespace position
                        wrappedText = wrappedText.substring(0, lastWhitespaceIndex) + '\n' + wrappedText.substring(lastWhitespaceIndex);
                        lineStartIndex = lastWhitespaceIndex;
                    } else {
                        // No whitespace found, but must wrap anyway; insert a newline before the current character to break the line
                        wrappedText = wrappedText.substring(0, wrappedText.length - 1) + '\n' + char;
                        lineStartIndex = wrappedText.length;
                    }
                    lastWhitespaceIndex = -1;
                }
            }

            let visibleText = wrappedText.split('\n');
            if (visibleText.length > maxLines) {
                visibleText = visibleText.slice(-maxLines);
            }
            for (let line of visibleText) {
                context.fillText(line, textDisplayParams.TEXT_X_OFFSET, currentY);
                currentY += textDisplayParams.LINE_HEIGHT;
            }

            textBuffer = visibleText.join('\n');

            textMesh.material.map.needsUpdate = true;
        }

        // ---------------------------------------------------------------------------
        // Setup retrying websocket for binary text in stream
        // ---------------------------------------------------------------------------
        function connectWebSocketText() {
            const socket = new WebSocket(WS_TEXT_URL);
            socket.binaryType = 'arraybuffer';

            socket.onopen = () => {
                // Connection opened
            };

            // Decode incoming text messages from possibly incomplete binary UTF-8 chunks
            const decoder = new TextDecoder('utf-8', { stream: true });

            socket.onmessage = (event) => {
                const text = decoder.decode(event.data, { stream: true });
                if (text) {
                    // Add text chunk to textBuffer
                    textBuffer += text;

                    updateTextCanvas();

                    if (text.trim().length !== 0)
                        playClickSound();
                }
            };

            socket.onclose = () => {
                setTimeout(connectWebSocketText, WS_TEXT_RETRY);
            };

            socket.onerror = (error) => {
                console.error('WebSocket text error:', error);
                socket.close();
            };
        }

        // ---------------------------------------------------------------------------
        // Event handlers
        // ---------------------------------------------------------------------------
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight); // Update composer size
        }

        function onDocumentMouseMove(event) {
            if (!cameraLocked) {
                mouse.x = (event.clientX - window.innerWidth / 2) * 8;
                mouse.y = (event.clientY - window.innerHeight / 2) * 8;
                targetCameraPosition.set(mouse.x, -mouse.y, camera.position.z);
            }
        }

        function onDocumentMouseLeave(event) {
            if (!cameraLocked) {
                targetCameraPosition.copy(initialCameraPosition);
            }
        }

        function onDocumentMouseWheel(event) {
            camera.position.z += event.deltaY * 0.5;
        }

        function onDocumentTouchStart(event) {
            if (event.touches.length === 1 && !cameraLocked) {
                mouse.x = (event.touches[0].clientX - window.innerWidth / 2) * 8;
                mouse.y = (event.touches[0].clientY - window.innerHeight / 2) * 8;
                targetCameraPosition.set(mouse.x, -mouse.y, camera.position.z);
            }
        }

        function onDocumentTouchMove(event) {
            if (event.touches.length === 1 && !cameraLocked) {
                mouse.x = (event.touches[0].clientX - window.innerWidth / 2) * 8;
                mouse.y = (event.touches[0].clientY - window.innerHeight / 2) * 8;
                targetCameraPosition.set(mouse.x, -mouse.y, camera.position.z);
            }
        }

        function onDocumentKeyDown(event) {
            if (event.code === 'Space') {
                cameraLocked = !cameraLocked;
            } else if (event.code === 'Delete') {
                textBuffer = "";
                updateTextCanvas();
            } else if (event.key === 'm') {
                toggleMute(!isMuted);
            } else if (event.key === 'c') {
                controlsVisible = !controlsVisible;
                if (controlsVisible) {
                    gui.show();
                } else {
                    gui.hide();
                }
            } else if (event.key === 'h') {
                const infoBox = document.getElementById('infoBox');
                if (infoBox.style.display === 'none') {
                    infoBox.style.display = 'block';
                } else {
                    infoBox.style.display = 'none';
                }
            } else if (event.key === 'l') {
                logControlPanelVariables();
            } else if (event.key === 'i') {
                invertColorPass.enabled = !invertColorPass.enabled;
            } else if (event.key === 'ArrowUp') {
                nudgeCamera(0, cameraSpeed); // Nudge camera up
            } else if (event.key === 'ArrowDown') {
                nudgeCamera(0, -cameraSpeed); // Nudge camera down
            } else if (event.key === 'ArrowLeft') {
                nudgeCamera(-cameraSpeed, 0); // Nudge camera left
            } else if (event.key === 'ArrowRight') {
                nudgeCamera(cameraSpeed, 0); // Nudge camera right
            }
        }

        function nudgeCamera(xAmount, yAmount) {
            camera.position.x += xAmount;
            camera.position.y += yAmount;
        }

        function logControlPanelVariables() {
            console.log('Current parameters:');

            // Camera position
            console.log('// Camera position');
            console.log(`camera.position.set(${camera.position.x}, ${camera.position.y}, ${camera.position.z});`);

            // Text display parameters
            console.log('// Text display parameters');
            for (const [key, value] of Object.entries(textDisplayParams)) {
                console.log(`textDisplayParams.${key} = ${JSON.stringify(value)};`);
            }

            // Bloom parameters
            console.log('// Bloom parameters');
            console.log(`bloomPass.strength = ${bloomPass.strength};`);
            console.log(`bloomPass.radius = ${bloomPass.radius};`);
            console.log(`bloomPass.threshold = ${bloomPass.threshold};`);

            // Lens Distortion parameters
            console.log('// Lens Distortion parameters');
            console.log(`lensDistortionPass.distortion.set(${lensDistortionPass.distortion.x}, ${lensDistortionPass.distortion.y});`);
            console.log(`lensDistortionPass.principalPoint.set(${lensDistortionPass.principalPoint.x}, ${lensDistortionPass.principalPoint.y});`);
            console.log(`lensDistortionPass.focalLength.set(${lensDistortionPass.focalLength.x}, ${lensDistortionPass.focalLength.y});`);
            console.log(`lensDistortionPass.skew = ${lensDistortionPass.skew};`);

            // Audio Gain
            console.log('// Audio Gain');
            console.log(`gainNode.gain.value = ${gainNode.gain.value};`);

            // Color Dipole parameters
            console.log('// Color Dipole parameters');
            console.log(`colorDipoleParams.color1 = ${JSON.stringify(colorDipoleParams.color1)};`);
            console.log(`colorDipoleParams.color2 = ${JSON.stringify(colorDipoleParams.color2)};`);
            console.log(`colorDipoleParams.enabled = ${colorDipoleParams.enabled};`);

            // Invert Color Pass
            console.log('// Invert Color Pass');
            console.log(`invertColorPass.enabled = ${invertColorPass.enabled};`);
        }
    </script>
</body>
</html>
