<!DOCTYPE html>
<html lang="en">
<head>
    <title>SEER</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>

    <video id="video" autoplay playsinline style="display:none"></video>

    <!-- Vertex Shader -->
    <script id="vs" type="x-shader/x-vertex">
        uniform sampler2D map;
        uniform float width;
        uniform float height;
        uniform float nearClipping, farClipping;
        uniform float pointSize;
        uniform float zOffset;
        varying vec2 vUv;
        const float XtoZ = 1.11146;
        const float YtoZ = 0.83359;
        void main() {
            vUv = vec2(position.x / width, position.y / height);
            vec4 color = texture2D(map, vUv);
            float depth = (color.r + color.g + color.b) / 3.0;
            float z = (1.0 - depth) * (farClipping - nearClipping) + nearClipping;
            vec4 pos = vec4(
                (position.x / width - 0.5) * z * XtoZ,
                (position.y / height - 0.5) * z * YtoZ,
                -z + zOffset,
                1.0);
            gl_PointSize = pointSize;
            gl_Position = projectionMatrix * modelViewMatrix * pos;
        }
    </script>

    <!-- Fragment Shader -->
    <script id="fs" type="x-shader/x-fragment">
        uniform sampler2D map;
        varying vec2 vUv;
        void main() {
            vec4 color = texture2D(map, vUv);
            gl_FragColor = vec4(color.r, color.g, color.b, 0.2);
        }
    </script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // Based on three.js examples

        import * as THREE from 'three';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // DESIGN related constants
        const TEXT_CANVAS_WIDTH = 600; // 320;
        const TEXT_CANVAS_HEIGHT = 480;
        const FONT_SIZE = 20;
        const FONT_FAMILY =  'Arial';
        const TEXT_COLOR = 'rgba(255, 255, 255, 0.7)';
        const LINE_HEIGHT = 24;
        const TEXT_OFFSET = 50;
        const FADE_HEIGHT = 100;
        const MAX_TEXT_WIDTH = TEXT_CANVAS_WIDTH - 40;
        const DISPLAY_CONTROLS = true; // Toggle to display or hide controls

        // Note: webcam stream is shown at native resolution

        // Other constants
        const NEAR_CLIPPING = 2012;
        const FAR_CLIPPING = 4000;
        const Z_OFFSET = 706;
        const POINT_SIZE = 2;
        const INITIAL_CAMERA_Z = 1500;

        let scene, camera, renderer;
        let geometry, mesh, material;
        let mouse, center;
        let textMesh;

        const initialCameraPosition = new THREE.Vector3(0, 0, INITIAL_CAMERA_Z);
        let targetCameraPosition = initialCameraPosition.clone();

        const textBuffer = [];

        init();

        async function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.copy(initialCameraPosition);

            scene = new THREE.Scene();
            center = new THREE.Vector3();
            center.z = -1000;

            const video = document.getElementById('video');
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;

            const texture = new THREE.VideoTexture(video);
            texture.minFilter = THREE.NearestFilter;

            geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array(TEXT_CANVAS_WIDTH * TEXT_CANVAS_HEIGHT * 3);
            for (let i = 0, j = 0, l = vertices.length; i < l; i += 3, j++) {
                vertices[i] = j % TEXT_CANVAS_WIDTH;
                vertices[i + 1] = Math.floor(j / TEXT_CANVAS_WIDTH);
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

            material = new THREE.ShaderMaterial({
                uniforms: {
                    'map': { value: texture },
                    'width': { value: TEXT_CANVAS_WIDTH },
                    'height': { value: TEXT_CANVAS_HEIGHT },
                    'nearClipping': { value: NEAR_CLIPPING },
                    'farClipping': { value: FAR_CLIPPING },
                    'pointSize': { value: POINT_SIZE },
                    'zOffset': { value: Z_OFFSET }
                },
                vertexShader: document.getElementById('vs').textContent,
                fragmentShader: document.getElementById('fs').textContent,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                depthWrite: false,
                transparent: true
            });

            mesh = new THREE.Points(geometry, material);
            scene.add(mesh);

            const canvas = document.createElement('canvas');
            canvas.width = TEXT_CANVAS_WIDTH;
            canvas.height = TEXT_CANVAS_HEIGHT;
            const context = canvas.getContext('2d');

            const textTexture = new THREE.CanvasTexture(canvas);
            textTexture.needsUpdate = true;

            const textMaterial = new THREE.MeshBasicMaterial({
                map: textTexture,
                transparent: true,
            });
            const textGeometry = new THREE.PlaneGeometry(TEXT_CANVAS_WIDTH, TEXT_CANVAS_HEIGHT);
            textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.set(0, 0, 100);
            scene.add(textMesh);

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setAnimationLoop(animate);
            container.appendChild(renderer.domElement);

            mouse = new THREE.Vector3(0, 0, 1);
            document.addEventListener('mousemove', onDocumentMouseMove);
            document.addEventListener('mouseleave', onDocumentMouseLeave);
            window.addEventListener('resize', onWindowResize);

            document.addEventListener('wheel', onDocumentMouseWheel);
            document.addEventListener('touchstart', onDocumentTouchStart, false);
            document.addEventListener('touchmove', onDocumentTouchMove, false);

            if (DISPLAY_CONTROLS) {
                const gui = new GUI();
                gui.add(material.uniforms.nearClipping, 'value', 1, 10000, 1.0).name('nearClipping');
                gui.add(material.uniforms.farClipping, 'value', 1, 10000, 1.0).name('farClipping');
                gui.add(material.uniforms.pointSize, 'value', 1, 10, 1.0).name('pointSize');
                gui.add(material.uniforms.zOffset, 'value', 0, 4000, 1.0).name('zOffset');
            }

            connectWebSocketVideo();
            connectWebSocketText();

            function connectWebSocketVideo() {
                const socket = new WebSocket('ws://localhost:8765');
                socket.binaryType = 'arraybuffer';

                socket.onopen = () => {
                    console.log('WebSocket connection for video opened');
                    setInterval(() => sendFrame(socket, video), 100);
                };

                socket.onclose = () => {
                    console.log('WebSocket connection for video closed, retrying...');
                    setTimeout(connectWebSocketVideo, 1000);
                };

                socket.onerror = (error) => {
                    console.log('WebSocket video error:', error);
                    socket.close();
                };
            }

            // Handle decoding of possibly incomplete UTF-8 chunks
            const decoder = new TextDecoder('utf-8', { stream: true });

            function connectWebSocketText() {
                const socket = new WebSocket('ws://localhost:8766');
                socket.binaryType = 'arraybuffer';

                socket.onopen = () => {
                    console.log('WebSocket connection for text opened');
                };

                socket.onmessage = (event) => {
                    // Decode the chunk, allowing partial characters to be buffered
                    const text = decoder.decode(event.data, { stream: true });
                    console.log('Received message:', text);
                    if (text) {
                        // Split the text by \n to handle multiple lines
                        const lines = text.split('\n');
                        lines.forEach((line, index) => {
                            if (index === 0) {
                                // For the first line, append to the last element of textBuffer
                                if (textBuffer.length > 0) {
                                    textBuffer[textBuffer.length - 1] += line;
                                } else {
                                    // If textBuffer is empty, just push the line
                                    textBuffer.push(line);
                                }
                            } else {
                                // For subsequent lines, add them as new elements to textBuffer
                                textBuffer.push(line);
                            }
                        });
                        updateTextCanvas(canvas, context, textBuffer);
                        textTexture.needsUpdate = true;
                    }
                };

                socket.onclose = () => {
                    console.log('WebSocket connection for text closed, retrying...');
                    setTimeout(connectWebSocketText, 1000);
                };

                socket.onerror = (error) => {
                    console.log('WebSocket text error:', error);
                    socket.close();
                };
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            mouse.x = (event.clientX - window.innerWidth / 2) * 8;
            mouse.y = (event.clientY - window.innerHeight / 2) * 8;
            targetCameraPosition.set(mouse.x, -mouse.y, camera.position.z);
        }

        function onDocumentMouseLeave(event) {
            targetCameraPosition.copy(initialCameraPosition);
        }

        function onDocumentMouseWheel(event) {
            camera.position.z += event.deltaY * 0.5;
        }

        function onDocumentTouchStart(event) {
            if (event.touches.length === 1) {
                mouse.x = (event.touches[0].clientX - window.innerWidth / 2) * 8;
                mouse.y = (event.touches[0].clientY - window.innerHeight / 2) * 8;
                targetCameraPosition.set(mouse.x, -mouse.y, camera.position.z);
            } else if (event.touches.length === 2) {
                touchStartDistance = getTouchDistance(event.touches);
            }
        }

        function onDocumentTouchMove(event) {
            if (event.touches.length === 1) {
                mouse.x = (event.touches[0].clientX - window.innerWidth / 2) * 8;
                mouse.y = (event.touches[0].clientY - window.innerHeight / 2) * 8;
                targetCameraPosition.set(mouse.x, -mouse.y, camera.position.z);
            } else if (event.touches.length === 2) {
                const currentDistance = getTouchDistance(event.touches);
                const distanceDelta = currentDistance - touchStartDistance;
                camera.position.z -= distanceDelta * 0.5;
                touchStartDistance = currentDistance;
            }
        }

        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function sendFrame(socket, video) {
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const context = canvas.getContext('2d');
            context.drawImage(video, 0, 0, canvas.width, canvas.height);

            canvas.toBlob((blob) => {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    blob.arrayBuffer().then(buffer => {
                        socket.send(buffer);
                    });
                    console.log('Sent video frame');
                }
            }, 'image/jpeg');
        }

        function updateTextCanvas(canvas, context, textBuffer) {
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.font = `bold ${FONT_SIZE}px ${FONT_FAMILY}`;
            context.textAlign = 'left';

            let currentY = TEXT_OFFSET;
            let visibleText = [];

            for (let i = 0; i < textBuffer.length; i++) {
                let words = textBuffer[i].split(' ');
                let currentLine = '';

                words.forEach(word => {
                    let testLine = currentLine + word + ' ';
                    let testWidth = context.measureText(testLine).width;

                    if (testWidth > MAX_TEXT_WIDTH && currentLine !== '') {
                        visibleText.push(currentLine);
                        currentLine = word + ' ';
                    } else {
                        currentLine = testLine;
                    }
                });

                visibleText.push(currentLine);
            }

            while ((visibleText.length * LINE_HEIGHT) > (canvas.height - TEXT_OFFSET)) {
                visibleText.shift();
            }

            visibleText.forEach((line, index) => {
                let alpha = 1;
                if (currentY < FADE_HEIGHT) {
                    alpha = Math.max((currentY / FADE_HEIGHT), 0);
                }

                context.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                context.fillText(line, 20, currentY);
                currentY += LINE_HEIGHT;
            });
        }

        function animate() {
            camera.position.lerp(targetCameraPosition, 0.05);
            camera.lookAt(center);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
